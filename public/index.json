[{
    "title": "Endangered Plants",
    "date": "",
    "description": "A TidyTuesday project exploring endangered plant life.",
    "body": " Today we are analyzing extinct and endangered plants for TidyTuesday.\nEvery week I find myself starting my research path at the truly excellent site Data-to-Viz by Yan Holtz and Conor Healy for inspiration on what I want to try and learn with R. The site is interactive and helps you figure out the best visualization given numerical or categorical data. It’s well worth a bookmark in your favorite browser.\nThis week’s dataset has three tables, many of which have several columns/features and ways in which to cut up the data. I decided to try something I’ve never done before, and build a Circular Barplot.\nThe code is long and complicated. I do not recommend this for beginner’s. However, the effect is pretty striking and it’s a nice weapon to have in the belt. I was tempted to build a stacked circular bar chart, which is REALLY impressive, but for my first foray into polar coordinates, I decided to just do a grouped bar chart, which honestly was pretty tough on its own.\nSetup\n# Contents of Setup.R. # Using Source method to suppress warnings and messages from Rmd output # library(tidyverse) # library(extrafont) # library(ggthemes) # library(tidyverse) # library(knitr) # library(kableExtra) Load Data # tuesdata \u0026lt;- tidytuesdayR::tt_load(\u0026#39;2020-08-18\u0026#39;) # threats \u0026lt;- tuesdata$threats threats \u0026lt;- readr::read_csv(\u0026#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-08-18/threats.csv\u0026#39;)  Explore Data skimr::skim(threats)  Table 1: Data summary          Name  threats    Number of rows  6000    Number of columns  8    _______________________     Column type frequency:     character  7    numeric  1    ________________________     Group variables  None     Variable type: character\n   skim_variable  n_missing  complete_rate  min  max  empty  n_unique  whitespace      binomial_name  0  1.00  11  35  0  500  0    country  0  1.00  4  44  0  72  0    continent  0  1.00  4  13  0  6  0    group  0  1.00  5  16  0  6  0    year_last_seen  180  0.97  9  11  0  7  0    red_list_category  0  1.00  7  19  0  2  0    threat_type  0  1.00  7  28  0  12  0     Variable type: numeric\n   skim_variable  n_missing  complete_rate  mean  sd  p0  p25  p50  p75  p100  hist      threatened  0  1  0.15  0.36  0  0  0  0  1  ▇▁▁▁▂      Explore Data MORE table(threats$threat_type, threats$threatened) ## ## 0 1 ## Agriculture \u0026amp; Aquaculture 273 227 ## Biological Resource Use 347 153 ## Climate Change 466 34 ## Commercial Development 414 86 ## Energy Production \u0026amp; Mining 455 45 ## Geological Events 482 18 ## Human Intrusions 480 20 ## Invasive Species 419 81 ## Natural System Modifications 397 103 ## Pollution 486 14 ## Transportation Corridor 489 11 ## Unknown 393 107  Data Processing data \u0026lt;- threats %\u0026gt;% filter(threatened == 1) %\u0026gt;% group_by(continent, country) %\u0026gt;% count(name = \u0026quot;threatened_plants\u0026quot;, sort = TRUE) %\u0026gt;% ungroup() %\u0026gt;% mutate(continent = factor(continent), country = ifelse(str_detect(country, \u0026quot;Saint Helena\u0026quot;), \u0026quot;Saint Helena\u0026quot;, country), threatened_plants = scales::rescale(threatened_plants, to = c(0, 100))) %\u0026gt;% filter(threatened_plants != 0)  Plotting # Set a number of \u0026#39;empty bar\u0026#39; to add at the end of each group empty_bar=3 to_add = data.frame( matrix(NA, empty_bar*nlevels(data$continent), ncol(data)) ) colnames(to_add) = colnames(data) to_add$continent = rep(levels(data$continent), each=empty_bar) data=rbind(data, to_add) data=data %\u0026gt;% arrange(continent) data$id=seq(1, nrow(data)) # Get the name and the y position of each label label_data=data number_of_bar=nrow(label_data) angle= 90 - 360 * (label_data$id-0.5) /number_of_bar # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0) label_data$hjust\u0026lt;-ifelse( angle \u0026lt; -90, 1, 0) label_data$angle\u0026lt;-ifelse(angle \u0026lt; -90, angle+180, angle) # prepare a data frame for base lines base_data=data %\u0026gt;% group_by(continent) %\u0026gt;% summarize(start=min(id), end=max(id) - empty_bar) %\u0026gt;% rowwise() %\u0026gt;% mutate(title=mean(c(start, end))) # prepare a data frame for grid (scales) grid_data = base_data grid_data$end = grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1 grid_data$start = grid_data$start - 1 grid_data=grid_data[-1,]  Build Plot p = ggplot(data, aes(x=as.factor(id), y=threatened_plants, fill=continent)) + # Note that id is a factor. If x is numeric, there is some space between the first bar geom_bar(aes(x=as.factor(id), y=threatened_plants, fill=continent), stat=\u0026quot;identity\u0026quot;, alpha=0.5) + # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it. geom_segment(data=grid_data, aes(x = end, y = 80, xend = start, yend = 80), colour = \u0026quot;grey\u0026quot;, alpha=1, size=0.3 , inherit.aes = FALSE ) + geom_segment(data=grid_data, aes(x = end, y = 60, xend = start, yend = 60), colour = \u0026quot;grey\u0026quot;, alpha=1, size=0.3 , inherit.aes = FALSE ) + geom_segment(data=grid_data, aes(x = end, y = 40, xend = start, yend = 40), colour = \u0026quot;grey\u0026quot;, alpha=1, size=0.3 , inherit.aes = FALSE ) + geom_segment(data=grid_data, aes(x = end, y = 20, xend = start, yend = 20), colour = \u0026quot;grey\u0026quot;, alpha=1, size=0.3 , inherit.aes = FALSE ) + # Add text showing the value of each 100/75/50/25 lines annotate(\u0026quot;text\u0026quot;, x = rep(max(data$id),4), y = c(20, 40, 60, 80), label = c(\u0026quot;20\u0026quot;, \u0026quot;40\u0026quot;, \u0026quot;60\u0026quot;, \u0026quot;80\u0026quot;) , color=\u0026quot;grey\u0026quot;, size=3 , angle=0, fontface=\u0026quot;bold\u0026quot;, hjust=1) + geom_bar(aes(x=as.factor(id), y=threatened_plants, fill=continent), stat=\u0026quot;identity\u0026quot;, alpha=0.5) + ylim(-100,120) + labs( title = \u0026quot;Number of Threatened Plants by Geo\u0026quot;, subtitle = \u0026quot;Scaled from 0-100\u0026quot;, caption = \u0026quot;Joseph Pope | @joepope44\u0026quot; ) + theme_minimal() + theme( legend.position = \u0026quot;none\u0026quot;, axis.text = element_blank(), axis.title = element_blank(), panel.grid = element_blank(), plot.title = element_text(hjust = 0.5, size = 24, family = \u0026quot;Garamond\u0026quot;), plot.subtitle = element_text(hjust = 0.5, family = \u0026quot;Garamond\u0026quot;), plot.caption = element_text(hjust = 0.5, family = \u0026quot;Garamond\u0026quot;) # plot.margin = unit(rep(-1,4), \u0026quot;cm\u0026quot;) \u0026lt;- this hides the plot title if not commented out ) + coord_polar() + geom_text(data=label_data, aes(x=id, y=threatened_plants+10, label=country, hjust=hjust), color=\u0026quot;black\u0026quot;, fontface=\u0026quot;bold\u0026quot;,alpha=0.7, size=3.5, angle= label_data$angle, inherit.aes = FALSE ) + # Add base line information geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5), colour = \u0026quot;black\u0026quot;, alpha=0.8, size=0.6 , inherit.aes = FALSE ) + geom_text(data=base_data, aes(x = title, y = -18, label=continent), hjust=c(1,1,.5,0,0,0), colour = \u0026quot;black\u0026quot;, alpha=0.8, size=3, fontface=\u0026quot;bold\u0026quot;, inherit.aes = FALSE) p  ",
    "ref": "/blog/endangered-plants/"
  },{
    "title": "Avatar: The Last Airbender",
    "date": "",
    "description": "A TidyTuesday project modelling Avatar TV show scripts.",
    "body": " Today we are looking at text data from the scripts for the TV show ‘Avatar: The Last Airbender’.\nI decided to see if certain characters that dominate a show, based on their word count, affects the ratings in a postive or negative way. It would be interesting to incorporate screen time as well, but all I have here is word count.\nSetup First we setup our enivronment and load the dataset.\nlibrary(tidytuesdayR) library(tidyverse) ## ── Attaching packages ────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.1 ✓ dplyr 1.0.0 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ───────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(knitr) library(kableExtra) ## ## Attaching package: \u0026#39;kableExtra\u0026#39; ## The following object is masked from \u0026#39;package:dplyr\u0026#39;: ## ## group_rows knitr::opts_chunk$set( echo = TRUE, fig.height = 5, fig.width = 8, message = FALSE, warning = FALSE, dpi = 180 ) Load the data\navatar \u0026lt;- readr::read_csv(\u0026#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-08-11/avatar.csv\u0026#39;)  Data Manipulation and Cleanup Next we create dataframes to capture the text data for all characters, the totals per episode, then join them.\nword_counts \u0026lt;- avatar %\u0026gt;% filter(character != \u0026quot;Scene Description\u0026quot;) %\u0026gt;% # removes non-character speaking text select(book, book_num, chapter_num, character, character_words, imdb_rating) %\u0026gt;% mutate(word_counts = str_count(character_words)) %\u0026gt;% group_by(book_num, chapter_num, character) %\u0026gt;% summarise(word_counts = sum(word_counts), rating = mean(imdb_rating)) %\u0026gt;% ungroup() word_totals \u0026lt;- word_counts %\u0026gt;% group_by(book_num, chapter_num) %\u0026gt;% summarise(total_words = sum(word_counts)) %\u0026gt;% ungroup() df \u0026lt;- word_counts %\u0026gt;% left_join(word_totals) %\u0026gt;% mutate(word_perc = word_counts / total_words) %\u0026gt;% arrange(book_num, chapter_num, -word_perc) Create list of top 6 characters by word count. We will only plot these characters as they have the most words compared to the other characters.\ntop_chars \u0026lt;- df %\u0026gt;% group_by(character) %\u0026gt;% summarise(char_word_counts = sum(word_counts)) %\u0026gt;% arrange(desc(char_word_counts)) %\u0026gt;% top_n(6, char_word_counts) %\u0026gt;% pull(character) Below is a first crack. I create a scatter plot and then use stat_ellipse to get a rough idea of the distribution and centroid for each character. Each point is an episode. I ignore which book/season of the series is involved, but it might be interesting to see how character’s evolve over the arc of the entire series.\ndf %\u0026gt;% filter(character %in% top_chars) %\u0026gt;% ggplot(aes(rating, word_perc)) + geom_point() + stat_ellipse() + facet_wrap(~ character) Now let’s make the plot pretty.\n Notice we can use the group.colors named list to dictate who gets assigned which color. Neat!\n library(ggtext) group.colors \u0026lt;- c(Sokka = \u0026quot;#1C3F6E\u0026quot;, Aang = \u0026quot;#EFFC93\u0026quot;, Katara = \u0026quot;#0F2347\u0026quot;, Iroh = \u0026quot;#a10000\u0026quot;, Zuko = \u0026quot;#a10000\u0026quot;, Toph = \u0026quot;#80C271\u0026quot;) p \u0026lt;- df %\u0026gt;% filter(character %in% top_chars) %\u0026gt;% ggplot(aes(rating, word_perc)) + geom_point(aes(color = character), alpha = 1, show.legend = FALSE) + stat_density_2d(alpha = .2, show.legend = FALSE) + scale_color_manual(values = group.colors) + scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + facet_wrap(~ character) + theme_minimal() + labs( x = \u0026quot;IMDB Rating\u0026quot;, y = \u0026quot;\u0026quot;, title = \u0026quot;\u0026lt;span style=\u0026#39;color:#a10000\u0026#39;\u0026gt;**Zuko**\u0026lt;/span\u0026gt;-heavy Episodes Maintain High Ratings\u0026quot;, subtitle = \u0026quot;Character Word Count / Total Word Count Per Each Episode\u0026quot;, caption = \u0026quot;Joseph Pope | @joepope44\u0026quot; ) + theme( text = element_text(family = \u0026quot;Verdana\u0026quot;), panel.background = element_rect(fill = \u0026quot;lightgrey\u0026quot;), panel.grid = element_blank(), plot.title = element_markdown(size = 20), strip.text = element_text(face = \u0026quot;bold\u0026quot;) ) p I use a density 2D plot to help show how the points are distributed.\nI don’t think this came out quite as informative as I would have liked, but it is interesting to see that Zuko has several episodes where he is speaking the most out of all characters, and those all appear to have relatively high ratings.\n ",
    "ref": "/blog/avatar-the-last-airbender/"
  },{
    "title": "About",
    "date": "",
    "description": "Data Science :: Analytics :: Visualization",
    "body": "Hi, I\u0026rsquo;m Joseph Pope, a data scientist/analyst/visualizer and business intelligence professional living in New York City.\nWhile I enjoy taking online classes to learn new skills and techniques, I have found that working on projects regularly really helps reinforce the lessons that I am learning. I have kept myself busy with open data #civictech type projecst in the past, Rstudio\u0026rsquo;s #TidyTuesday weekly projects, and other ad hoc work with Tableau, R and python.\nProjects My first tweet for TidyTuesday was back in January. It is interesting to watch the progress as my data anlaysis skills have improved alongside my visualization skills.\nFirst #TidyTuesday attempt to start off 2020. Trying a dumbell plot (ggalt package) with min and max temps for Australia. #r4ds #rstats Code here: https://t.co/HcIu0NtY1k pic.twitter.com/G5MbQNPvfW\n\u0026mdash; Joseph W Pope (@joepope44) January 9, 2020  #TidyTuesday 2020 Portfolio\nR Script to Scrape NBA Playoff Data\nOther Github Repos\n",
    "ref": "/about/"
  },{
    "title": "Coffee Ratings",
    "date": "",
    "description": "TidyTuesday project modelling coffee ratings",
    "body": "\nIntro Today I am going to explore Coffee Ratings for this week’s Tidy Tuesday challenge. The data comes from the Coffee Quality Database. The great thing about Tidy Tuesday is that we can do whatever we want with the data. There are no rules or directions!\nThis data is very interesting with many features and looks ripe for a predictive model. I can use the various ratings provided to predict either a quantitative method, like what the ‘total_cup_score’ (Overall rating) is, or a qualitative measure, like what species of bean (Arabica or Robusta) or perhaps the country of origin.\nPredicting scores strikes me as a classic regression problem, best tackled by linear models or random forests, and classification could be solved with logistic regression, Naive Bayes, SVM or even neural networks. I’ve NEVER used tidymodels before, so let’s give it a go, make some mistakes, and see what we can learn.\nBut first, some brief background of our data from the TidyTuesday repo:\n There is data for both Arabica and Robusta beans, across many countries and professionally rated on a 0-100 scale. All sorts of scoring/ratings for things like acidity, sweetness, fragrance, balance, etc - may be useful for either separating into visualizations/categories or for modeling/recommenders.\n  Wikipedia on Coffee Beans:\n  The two most economically important varieties of coffee plant are the Arabica and the Robusta; ~60% of the coffee produced worldwide is Arabica and ~40% is Robusta. Arabica beans consist of 0.8–1.4% caffeine and Robusta beans consist of 1.7–4% caffeine.\n Setup\nlibrary(tidytuesdayR) library(tidyverse) ## ── Attaching packages ──────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.1 ✓ dplyr 1.0.0 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ─────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(tidymodels) ## ── Attaching packages ─────────────────── tidymodels 0.1.0 ── ## ✓ broom 0.5.6 ✓ rsample 0.0.6 ## ✓ dials 0.0.6 ✓ tune 0.1.0 ## ✓ infer 0.5.1 ✓ workflows 0.1.1 ## ✓ parsnip 0.1.1 ✓ yardstick 0.0.6 ## ✓ recipes 0.1.12 ## ── Conflicts ────────────────────── tidymodels_conflicts() ── ## x scales::discard() masks purrr::discard() ## x dplyr::filter() masks stats::filter() ## x recipes::fixed() masks stringr::fixed() ## x dplyr::lag() masks stats::lag() ## x dials::margin() masks ggplot2::margin() ## x yardstick::spec() masks readr::spec() ## x recipes::step() masks stats::step() library(knitr) library(kableExtra) ## ## Attaching package: \u0026#39;kableExtra\u0026#39; ## The following object is masked from \u0026#39;package:dplyr\u0026#39;: ## ## group_rows knitr::opts_chunk$set( fig.height = 5, fig.width = 8, message = FALSE, warning = FALSE, dpi = 180, include = TRUE ) Load the data\ntuesdata \u0026lt;- tidytuesdayR::tt_load(2020, week = 28) coffee_ratings \u0026lt;- tuesdata$coffee_ratings  EDA Now that we have our data and let’s dive in. Let’s review the summary statistics with skimr.\ncoffee_ratings %\u0026gt;% skimr::skim()  Table 1: Data summary          Name  Piped data    Number of rows  1339    Number of columns  43    _______________________     Column type frequency:     character  24    numeric  19    ________________________     Group variables  None     Variable type: character\n   skim_variable  n_missing  complete_rate  min  max  empty  n_unique  whitespace      species  0  1.00  7  7  0  2  0    owner  7  0.99  3  50  0  315  0    country_of_origin  1  1.00  4  28  0  36  0    farm_name  359  0.73  1  73  0  571  0    lot_number  1063  0.21  1  71  0  227  0    mill  315  0.76  1  77  0  460  0    ico_number  151  0.89  1  40  0  847  0    company  209  0.84  3  73  0  281  0    altitude  226  0.83  1  41  0  396  0    region  59  0.96  2  76  0  356  0    producer  231  0.83  1  100  0  691  0    bag_weight  0  1.00  1  8  0  56  0    in_country_partner  0  1.00  7  85  0  27  0    harvest_year  47  0.96  3  24  0  46  0    grading_date  0  1.00  13  20  0  567  0    owner_1  7  0.99  3  50  0  319  0    variety  226  0.83  4  21  0  29  0    processing_method  170  0.87  5  25  0  5  0    color  218  0.84  4  12  0  4  0    expiration  0  1.00  13  20  0  566  0    certification_body  0  1.00  7  85  0  26  0    certification_address  0  1.00  40  40  0  32  0    certification_contact  0  1.00  40  40  0  29  0    unit_of_measurement  0  1.00  1  2  0  2  0     Variable type: numeric\n   skim_variable  n_missing  complete_rate  mean  sd  p0  p25  p50  p75  p100  hist      total_cup_points  0  1.00  82.09  3.50  0  81.08  82.50  83.67  90.58  ▁▁▁▁▇    number_of_bags  0  1.00  154.18  129.99  0  14.00  175.00  275.00  1062.00  ▇▇▁▁▁    aroma  0  1.00  7.57  0.38  0  7.42  7.58  7.75  8.75  ▁▁▁▁▇    flavor  0  1.00  7.52  0.40  0  7.33  7.58  7.75  8.83  ▁▁▁▁▇    aftertaste  0  1.00  7.40  0.40  0  7.25  7.42  7.58  8.67  ▁▁▁▁▇    acidity  0  1.00  7.54  0.38  0  7.33  7.58  7.75  8.75  ▁▁▁▁▇    body  0  1.00  7.52  0.37  0  7.33  7.50  7.67  8.58  ▁▁▁▁▇    balance  0  1.00  7.52  0.41  0  7.33  7.50  7.75  8.75  ▁▁▁▁▇    uniformity  0  1.00  9.83  0.55  0  10.00  10.00  10.00  10.00  ▁▁▁▁▇    clean_cup  0  1.00  9.84  0.76  0  10.00  10.00  10.00  10.00  ▁▁▁▁▇    sweetness  0  1.00  9.86  0.62  0  10.00  10.00  10.00  10.00  ▁▁▁▁▇    cupper_points  0  1.00  7.50  0.47  0  7.25  7.50  7.75  10.00  ▁▁▁▇▁    moisture  0  1.00  0.09  0.05  0  0.09  0.11  0.12  0.28  ▃▇▅▁▁    category_one_defects  0  1.00  0.48  2.55  0  0.00  0.00  0.00  63.00  ▇▁▁▁▁    quakers  1  1.00  0.17  0.83  0  0.00  0.00  0.00  11.00  ▇▁▁▁▁    category_two_defects  0  1.00  3.56  5.31  0  0.00  2.00  4.00  55.00  ▇▁▁▁▁    altitude_low_meters  230  0.83  1750.71  8669.44  1  1100.00  1310.64  1600.00  190164.00  ▇▁▁▁▁    altitude_high_meters  230  0.83  1799.35  8668.81  1  1100.00  1350.00  1650.00  190164.00  ▇▁▁▁▁    altitude_mean_meters  230  0.83  1775.03  8668.63  1  1100.00  1310.64  1600.00  190164.00  ▇▁▁▁▁      Check Initial Assumptions I originally wanted to predict “total_cup_points”. However, after some review it appears that this field is simply the sum of ten other ratings, from aroma to cupper_points. What I really want to predict is Cupper Points. This is the reviewer’s (aka the Cupper’s) personal overall rating for the cup of joe. I can use this as dependant variable in a regression analysis. This should help me identify which features (aroma, acidity, elevation, country of origin?) influence the final rating the most.\n Potential Features Before we dig further into the data, let’s speculate what might factors go into a superior coffee bean. If coffee is like wine, then perhaps region (lat, long, altitude, preciptation, average hours of sunlight, etc) makes a big difference. Perhaps certain companies utilize best practices and farming techniques. Maybe certain processing methods are better than others. We are given the testing date and the expiration date, so we can add a feature that measures how fresh the beans are. These features and more could be really important or totally useless. I have no idea! Let’s see what the data has to say about it.\nThe wiki in the readme suggests that coffee beans are split 60/40 worldwide, by Arabica and Robusta. However, for this analysis the split is much more imbalanced. I thought it would be very interesting to build an Arabica vs. Robusta classifier but with such an imbalanced set I don’t think upsampling or other methods will be enough to build a robust model.\ntable(coffee_ratings$species) ## ## Arabica Robusta ## 1311 28 Let’s take a peak at the distribution of country of origin field. It is mentioned in the articles that Ethiopia wins top prize, however most of the coffees are from Central and South America.\ncoffee_ratings %\u0026gt;% group_by(country_of_origin) %\u0026gt;% tally() %\u0026gt;% top_n(., 10) %\u0026gt;% arrange(desc(n)) ## # A tibble: 10 x 2 ## country_of_origin n ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; ## 1 Mexico 236 ## 2 Colombia 183 ## 3 Guatemala 181 ## 4 Brazil 132 ## 5 Taiwan 75 ## 6 United States (Hawaii) 73 ## 7 Honduras 53 ## 8 Costa Rica 51 ## 9 Ethiopia 44 ## 10 Tanzania, United Republic Of 40 Let’s pull this list of top 10 countries into a list to reference later.\ntop_countries \u0026lt;- coffee_ratings %\u0026gt;% group_by(country_of_origin) %\u0026gt;% tally() %\u0026gt;% top_n(., 10) %\u0026gt;% arrange(desc(n)) %\u0026gt;% pull(country_of_origin) Out of curiousity, let’s see the count of coffee bean color. This was news to me, but apparently coffee beans are mostly blue or green in color when fresh. It is only after roasting that the color darkens to that familiar, uh, “coffee-brown” color. If you learn nothing else today, you can at least learn this.\nThe Coffee Bean Spectrum\n table(coffee_ratings$color) ## ## Blue-Green Bluish-Green Green None ## 85 114 870 52 Robusta is seen below with a higher modal peak, suggesting the species, known for its higher caffeine levels, is rated higher than Arabica. This could be due to a small sample size though.\ncoffee_ratings %\u0026gt;% mutate(id = row_number()) %\u0026gt;% select(id, species, cupper_points) %\u0026gt;% ggplot(aes(cupper_points, fill = species)) + geom_density(alpha = 0.1)  # geom_histogram(position = \u0026quot;identity\u0026quot;, alpha = 0.7, show.legend = FALSE)  TIDYMODELS I have never used tidymodels, so let’s see how this goes. Let’s try to tackle the regression model first. From the skim package, we know we have no missing values or junky data for this. Nice!\nFirst thing to do is narrow our data and make it ripe for modeling. TidyTuesday mentions that Yorgos Askalidis already determined that altitude, processing_method and color have no bearing to the cupping score, and I think that makes sense. I will omit those features for now. That leaves us with species, country of origin and several ratings and measurements of the coffee samples. I am going to take the top ten countries only (out of 36 in the data) and lump the rest into “Other” with forcats. This is simply to speed up the processing without losing too much information gain for the feature.\n Note - I went back after trying the models a few times and removed ‘species’. In this smaller, filtered dataset there are only 3 records with Robusta coffee beans. It caused me some issues, and with only 3 members of the minority class, I decided to just remove it completely.\n coffee \u0026lt;- coffee_ratings %\u0026gt;% mutate(id = row_number()) %\u0026gt;% # add ID field, convert NA to Other select(id, country_of_origin, variety, aroma:moisture) %\u0026gt;% # select features mutate(country_of_origin = case_when( country_of_origin %in% top_countries ~ country_of_origin, TRUE ~ \u0026quot;Other\u0026quot; )) %\u0026gt;% mutate_if(is.character, as.factor) %\u0026gt;% # convert country and variety to factors filter(cupper_points != 0) %\u0026gt;% # remove 0 point scores as junk data drop_na() # drop NA for country and variety fields. only affects 200 records Split the data\n Note - I initially tried to stratify by species, even though there aren’t many Robusta coffee samples in the data. I ended up removing this due to the severe class imbalance. It may have been worth the effort to upsample Robusta and then stratify by species.\n set.seed(1234) coffee_split \u0026lt;- coffee %\u0026gt;% initial_split() coffee_train \u0026lt;- training(coffee_split) coffee_test \u0026lt;- testing(coffee_split) Naive linear model with no scaling or pre-processing\nlm_spec \u0026lt;- linear_reg() %\u0026gt;% set_engine(engine = \u0026quot;lm\u0026quot;) lm_spec ## Linear Regression Model Specification (regression) ## ## Computational engine: lm ## Linear Regression Model Specification (regression) ## ## Computational engine: lm lm_fit \u0026lt;- lm_spec %\u0026gt;% fit(cupper_points ~ ., data = coffee_train ) lm_fit ## parsnip model object ## ## Fit time: 10ms ## ## Call: ## stats::lm(formula = formula, data = data) ## ## Coefficients: ## (Intercept) ## 2.501509 ## id ## -0.000309 ## country_of_originColombia ## -0.099026 ## country_of_originCosta Rica ## -0.020488 ## country_of_originEthiopia ## 0.029321 ## country_of_originGuatemala ## -0.045107 ## country_of_originHonduras ## -0.013921 ## country_of_originMexico ## 0.030019 ## country_of_originOther ## 0.003251 ## country_of_originTaiwan ## -0.134839 ## country_of_originTanzania, United Republic Of ## 0.052325 ## country_of_originUnited States (Hawaii) ## -0.316031 ## varietyBlue Mountain ## -0.234205 ## varietyBourbon ## -0.004215 ## varietyCatimor ## 0.018467 ## varietyCatuai ## 0.015110 ## varietyCaturra ## 0.036397 ## varietyEthiopian Heirlooms ## -0.094942 ## varietyEthiopian Yirgacheffe ## 0.011110 ## varietyGesha ## 0.046588 ## varietyHawaiian Kona ## 0.296594 ## varietyJava ## 0.007740 ## varietyMandheling ## 0.001044 ## varietyMarigojipe ## -0.006565 ## varietyMundo Novo ## -0.047911 ## varietyOther ## -0.019686 ## varietyPacamara ## -0.067598 ## varietyPacas ## -0.001151 ## varietyPache Comun ## -0.134161 ## varietyPeaberry ## -0.022037 ## varietyRuiru 11 ## -0.016437 ## varietySL14 ## 0.017365 ## varietySL28 ## -0.256004 ## varietySL34 ## -0.055397 ## varietySulawesi ## 0.040376 ## varietySumatra ## 0.096590 ## varietySumatra Lintong ## 0.080224 ## varietyTypica ## -0.035801 ## varietyYellow Bourbon ## 0.086077 ## aroma ## -0.003595 ## flavor ## 0.241316 ## aftertaste ## 0.278652 ## acidity ## 0.040398 ## body ## 0.022329 ## balance ## 0.194880 ## uniformity ## -0.022991 ## clean_cup ## 0.013229 ## sweetness ## -0.043329 ## moisture ## -0.505604 library(ranger) rf_spec \u0026lt;- rand_forest(mode = \u0026quot;regression\u0026quot;) %\u0026gt;% set_engine(\u0026quot;ranger\u0026quot;) rf_spec ## Random Forest Model Specification (regression) ## ## Computational engine: ranger ## Random Forest Model Specification (regression) ## ## Computational engine: ranger rf_fit \u0026lt;- rf_spec %\u0026gt;% fit(cupper_points ~ ., data = coffee_train ) rf_fit ## parsnip model object ## ## Fit time: 468ms ## Ranger result ## ## Call: ## ranger::ranger(formula = formula, data = data, num.threads = 1, verbose = FALSE, seed = sample.int(10^5, 1)) ## ## Type: Regression ## Number of trees: 500 ## Sample size: 834 ## Number of independent variables: 13 ## Mtry: 3 ## Target node size: 5 ## Variable importance mode: none ## Splitrule: variance ## OOB prediction error (MSE): 0.04135314 ## R squared (OOB): 0.7374583 Both models produce a hefty R squared, \u0026gt; .7! This makes me nervous as it’s likely too good to be true (overfit). I know that I skipped some preprocessing steps just to see how these models worked, so let’s go back and see if some recipes can bring my models back down to earth.\n Preprocessing With Recipes Let’s create a bland, vanilla recipe to start off  rec_obj \u0026lt;- recipe(cupper_points ~ ., data = coffee_train) %\u0026gt;% update_role(id, new_role = \u0026quot;ID\u0026quot;) %\u0026gt;% step_normalize(all_predictors(), -all_nominal()) %\u0026gt;% step_dummy(all_nominal()) summary(rec_obj) ## # A tibble: 14 x 4 ## variable type role source ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; ## 1 id numeric ID original ## 2 country_of_origin nominal predictor original ## 3 variety nominal predictor original ## 4 aroma numeric predictor original ## 5 flavor numeric predictor original ## 6 aftertaste numeric predictor original ## 7 acidity numeric predictor original ## 8 body numeric predictor original ## 9 balance numeric predictor original ## 10 uniformity numeric predictor original ## 11 clean_cup numeric predictor original ## 12 sweetness numeric predictor original ## 13 moisture numeric predictor original ## 14 cupper_points numeric outcome original I tell the recipe not to use the “id” column in the analysis and we can see that it is classified as a “ID” and not “predictor”. I run summary on the recipe object and can see the type of role the variables have, as well as the type. It is important to note that ‘nominal’ is yet another term to describe a factor/string/non-numeric.\nThen I use the step_* functions to normalize the data (it centers and scales numerical features) and to create dummy variables for all of my nominal (non-numeric) features.\nSo we built our recipe. Next step is to prep and juice. I’m getting thirsty.\ncoff_train \u0026lt;- juice(prep(rec_obj)) dim(coff_train) ## [1] 834 50 names(coff_train) ## [1] \u0026quot;id\u0026quot; ## [2] \u0026quot;aroma\u0026quot; ## [3] \u0026quot;flavor\u0026quot; ## [4] \u0026quot;aftertaste\u0026quot; ## [5] \u0026quot;acidity\u0026quot; ## [6] \u0026quot;body\u0026quot; ## [7] \u0026quot;balance\u0026quot; ## [8] \u0026quot;uniformity\u0026quot; ## [9] \u0026quot;clean_cup\u0026quot; ## [10] \u0026quot;sweetness\u0026quot; ## [11] \u0026quot;moisture\u0026quot; ## [12] \u0026quot;cupper_points\u0026quot; ## [13] \u0026quot;country_of_origin_Colombia\u0026quot; ## [14] \u0026quot;country_of_origin_Costa.Rica\u0026quot; ## [15] \u0026quot;country_of_origin_Ethiopia\u0026quot; ## [16] \u0026quot;country_of_origin_Guatemala\u0026quot; ## [17] \u0026quot;country_of_origin_Honduras\u0026quot; ## [18] \u0026quot;country_of_origin_Mexico\u0026quot; ## [19] \u0026quot;country_of_origin_Other\u0026quot; ## [20] \u0026quot;country_of_origin_Taiwan\u0026quot; ## [21] \u0026quot;country_of_origin_Tanzania..United.Republic.Of\u0026quot; ## [22] \u0026quot;country_of_origin_United.States..Hawaii.\u0026quot; ## [23] \u0026quot;variety_Blue.Mountain\u0026quot; ## [24] \u0026quot;variety_Bourbon\u0026quot; ## [25] \u0026quot;variety_Catimor\u0026quot; ## [26] \u0026quot;variety_Catuai\u0026quot; ## [27] \u0026quot;variety_Caturra\u0026quot; ## [28] \u0026quot;variety_Ethiopian.Heirlooms\u0026quot; ## [29] \u0026quot;variety_Ethiopian.Yirgacheffe\u0026quot; ## [30] \u0026quot;variety_Gesha\u0026quot; ## [31] \u0026quot;variety_Hawaiian.Kona\u0026quot; ## [32] \u0026quot;variety_Java\u0026quot; ## [33] \u0026quot;variety_Mandheling\u0026quot; ## [34] \u0026quot;variety_Marigojipe\u0026quot; ## [35] \u0026quot;variety_Moka.Peaberry\u0026quot; ## [36] \u0026quot;variety_Mundo.Novo\u0026quot; ## [37] \u0026quot;variety_Other\u0026quot; ## [38] \u0026quot;variety_Pacamara\u0026quot; ## [39] \u0026quot;variety_Pacas\u0026quot; ## [40] \u0026quot;variety_Pache.Comun\u0026quot; ## [41] \u0026quot;variety_Peaberry\u0026quot; ## [42] \u0026quot;variety_Ruiru.11\u0026quot; ## [43] \u0026quot;variety_SL14\u0026quot; ## [44] \u0026quot;variety_SL28\u0026quot; ## [45] \u0026quot;variety_SL34\u0026quot; ## [46] \u0026quot;variety_Sulawesi\u0026quot; ## [47] \u0026quot;variety_Sumatra\u0026quot; ## [48] \u0026quot;variety_Sumatra.Lintong\u0026quot; ## [49] \u0026quot;variety_Typica\u0026quot; ## [50] \u0026quot;variety_Yellow.Bourbon\u0026quot; coff_train ## # A tibble: 834 x 50 ## id aroma flavor aftertaste acidity body balance uniformity clean_cup ## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 2 3.84 3.55 3.27 3.35 3.35 2.68 0.312 0.225 ## 2 3 2.77 3.03 3.04 2.84 3.02 2.68 0.312 0.225 ## 3 5 2.22 3.03 2.54 3.10 3.35 2.41 0.312 0.225 ## 4 10 1.66 3.27 3.27 3.10 0.575 2.68 0.312 0.225 ## 5 12 2.22 2.78 2.30 2.56 2.09 1.94 0.312 0.225 ## 6 13 1.66 3.55 2.77 2.84 1.80 1.68 0.312 0.225 ## 7 16 1.40 3.03 3.51 2.05 2.42 1.44 0.312 0.225 ## 8 19 2.77 2.26 2.03 2.05 1.50 1.44 0.312 0.225 ## 9 21 1.40 2.26 2.03 3.10 2.72 1.44 0.312 0.225 ## 10 23 1.96 2.26 2.30 1.51 1.17 1.94 0.312 0.225 ## # … with 824 more rows, and 41 more variables: sweetness \u0026lt;dbl\u0026gt;, moisture \u0026lt;dbl\u0026gt;, ## # cupper_points \u0026lt;dbl\u0026gt;, country_of_origin_Colombia \u0026lt;dbl\u0026gt;, ## # country_of_origin_Costa.Rica \u0026lt;dbl\u0026gt;, country_of_origin_Ethiopia \u0026lt;dbl\u0026gt;, ## # country_of_origin_Guatemala \u0026lt;dbl\u0026gt;, country_of_origin_Honduras \u0026lt;dbl\u0026gt;, ## # country_of_origin_Mexico \u0026lt;dbl\u0026gt;, country_of_origin_Other \u0026lt;dbl\u0026gt;, ## # country_of_origin_Taiwan \u0026lt;dbl\u0026gt;, ## # country_of_origin_Tanzania..United.Republic.Of \u0026lt;dbl\u0026gt;, ## # country_of_origin_United.States..Hawaii. \u0026lt;dbl\u0026gt;, ## # variety_Blue.Mountain \u0026lt;dbl\u0026gt;, variety_Bourbon \u0026lt;dbl\u0026gt;, variety_Catimor \u0026lt;dbl\u0026gt;, ## # variety_Catuai \u0026lt;dbl\u0026gt;, variety_Caturra \u0026lt;dbl\u0026gt;, ## # variety_Ethiopian.Heirlooms \u0026lt;dbl\u0026gt;, variety_Ethiopian.Yirgacheffe \u0026lt;dbl\u0026gt;, ## # variety_Gesha \u0026lt;dbl\u0026gt;, variety_Hawaiian.Kona \u0026lt;dbl\u0026gt;, variety_Java \u0026lt;dbl\u0026gt;, ## # variety_Mandheling \u0026lt;dbl\u0026gt;, variety_Marigojipe \u0026lt;dbl\u0026gt;, ## # variety_Moka.Peaberry \u0026lt;dbl\u0026gt;, variety_Mundo.Novo \u0026lt;dbl\u0026gt;, variety_Other \u0026lt;dbl\u0026gt;, ## # variety_Pacamara \u0026lt;dbl\u0026gt;, variety_Pacas \u0026lt;dbl\u0026gt;, variety_Pache.Comun \u0026lt;dbl\u0026gt;, ## # variety_Peaberry \u0026lt;dbl\u0026gt;, variety_Ruiru.11 \u0026lt;dbl\u0026gt;, variety_SL14 \u0026lt;dbl\u0026gt;, ## # variety_SL28 \u0026lt;dbl\u0026gt;, variety_SL34 \u0026lt;dbl\u0026gt;, variety_Sulawesi \u0026lt;dbl\u0026gt;, ## # variety_Sumatra \u0026lt;dbl\u0026gt;, variety_Sumatra.Lintong \u0026lt;dbl\u0026gt;, variety_Typica \u0026lt;dbl\u0026gt;, ## # variety_Yellow.Bourbon \u0026lt;dbl\u0026gt; Baking applies the pre-processing steps that were ‘juiced’ above to the test data. This way, the train and test data will have the same pre-processing steps (aka recipe) applied to them. Clever!\ncoff_test \u0026lt;- rec_obj %\u0026gt;% prep() %\u0026gt;% bake(coffee_test)  So now we see all our predictors including all the dummy variables that were generated. Neat.\n Better, Faster, Stronger Now we can go back to the linear and random forest regression models used earlier, but now substitute the data with better processing. I think I see why they went with the “recipe” motif! Like baking, I can swap in ingredients without having to start over from scratch.\nlm_fit1 \u0026lt;- fit(lm_spec, cupper_points ~ ., coff_train) glance(lm_fit1$fit) ## # A tibble: 1 x 11 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 0.751 0.736 0.204 49.4 2.55e-203 49 168. -237. -0.335 ## # … with 2 more variables: deviance \u0026lt;dbl\u0026gt;, df.residual \u0026lt;int\u0026gt; tidy(lm_fit1) %\u0026gt;% arrange(desc(abs(statistic))) ## # A tibble: 49 x 5 ## term estimate std.error statistic p.value ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 (Intercept) 7.71 0.109 70.7 0. ## 2 id -0.000309 0.0000479 -6.45 1.99e-10 ## 3 aftertaste 0.0944 0.0163 5.79 1.01e- 8 ## 4 balance 0.0665 0.0132 5.02 6.39e- 7 ## 5 flavor 0.0789 0.0173 4.56 6.07e- 6 ## 6 country_of_origin_Taiwan -0.135 0.0462 -2.92 3.63e- 3 ## 7 moisture -0.0230 0.00823 -2.79 5.36e- 3 ## 8 country_of_origin_Colombia -0.0990 0.0434 -2.28 2.28e- 2 ## 9 sweetness -0.0177 0.00819 -2.16 3.09e- 2 ## 10 variety_SL28 -0.256 0.119 -2.16 3.14e- 2 ## # … with 39 more rows lm_predicted \u0026lt;- augment(lm_fit1$fit, data = coff_train) select(lm_predicted, id, cupper_points, .fitted:.std.resid) ## # A tibble: 834 x 9 ## id cupper_points .fitted .se.fit .resid .hat .sigma .cooksd .std.resid ## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 2 8.58 8.52 0.0749 0.0562 0.135 0.204 2.80e-4 0.297 ## 2 3 9.25 8.45 0.0431 0.795 0.0447 0.202 1.52e-2 3.99 ## 3 5 8.58 8.39 0.0707 0.187 0.120 0.204 2.67e-3 0.977 ## 4 10 8.5 8.49 0.0721 0.00789 0.125 0.204 5.00e-6 0.0414 ## 5 12 8.5 8.34 0.0379 0.162 0.0345 0.204 4.75e-4 0.807 ## 6 13 8.33 8.43 0.0435 -0.0979 0.0456 0.204 2.36e-4 -0.492 ## 7 16 8.17 8.43 0.0443 -0.264 0.0472 0.204 1.78e-3 -1.33 ## 8 19 8.42 8.21 0.0570 0.206 0.0783 0.204 1.92e-3 1.05 ## 9 21 8.17 8.25 0.0407 -0.0779 0.0398 0.204 1.29e-4 -0.390 ## 10 23 8.58 8.24 0.0402 0.344 0.0388 0.204 2.44e-3 1.72 ## # … with 824 more rows ggplot(lm_predicted, aes(.fitted, cupper_points)) + geom_point(alpha = .2) + ggrepel::geom_label_repel(aes(label = id), data = filter(lm_predicted, abs(.resid) \u0026gt; 2)) + labs(title = \u0026quot;Linear Model: Actual vs. Predicted Cupper Points\u0026quot;) + geom_smooth() Whoa, what’s up with coffee sample 963? We predicted a score of 7.4 or so, and the real score was a 5.25. This appears just to be a major outlier, so we can likely ignore.\nfilter(coffee, id == 963) ## # A tibble: 1 x 14 ## id country_of_orig… variety aroma flavor aftertaste acidity body balance ## \u0026lt;int\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 963 Taiwan Typica 7.83 7.75 7.67 7.83 7.83 7.75 ## # … with 5 more variables: uniformity \u0026lt;dbl\u0026gt;, clean_cup \u0026lt;dbl\u0026gt;, sweetness \u0026lt;dbl\u0026gt;, ## # cupper_points \u0026lt;dbl\u0026gt;, moisture \u0026lt;dbl\u0026gt; Now let’s repeat for the random forest model. Note - glance does not work for ranger objects like rf_fit1$fit.\nrf_fit1 \u0026lt;- fit(rf_spec, cupper_points ~ ., coff_train) rf_fit1$fit ## Ranger result ## ## Call: ## ranger::ranger(formula = formula, data = data, num.threads = 1, verbose = FALSE, seed = sample.int(10^5, 1)) ## ## Type: Regression ## Number of trees: 500 ## Sample size: 834 ## Number of independent variables: 49 ## Mtry: 7 ## Target node size: 5 ## Variable importance mode: none ## Splitrule: variance ## OOB prediction error (MSE): 0.04222097 ## R squared (OOB): 0.7319486 rf_predicted \u0026lt;- bind_cols(.fitted = rf_fit1$fit$predictions, data = coff_train) select(rf_predicted, id, cupper_points, .fitted) ## # A tibble: 834 x 3 ## id cupper_points .fitted ## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 2 8.58 8.60 ## 2 3 9.25 8.31 ## 3 5 8.58 8.54 ## 4 10 8.5 8.41 ## 5 12 8.5 8.30 ## 6 13 8.33 8.36 ## 7 16 8.17 8.33 ## 8 19 8.42 8.24 ## 9 21 8.17 8.29 ## 10 23 8.58 8.14 ## # … with 824 more rows ggplot(rf_predicted, aes(.fitted, cupper_points)) + geom_point(alpha = .2) + # ggrepel::geom_label_repel(aes(label = id), # data = filter(rf_predicted, abs(.resid) \u0026gt; 2)) + labs(title = \u0026quot;Random Forest: Actual vs. Predicted Cupper Points\u0026quot;) + geom_smooth() results_train \u0026lt;- lm_fit1 %\u0026gt;% predict(new_data = coff_train) %\u0026gt;% mutate( truth = coff_train$cupper_points, model = \u0026quot;lm\u0026quot; ) %\u0026gt;% bind_rows(rf_fit1 %\u0026gt;% predict(new_data = coff_train) %\u0026gt;% mutate( truth = coff_train$cupper_points, model = \u0026quot;rf\u0026quot; )) results_train %\u0026gt;% group_by(model) %\u0026gt;% rmse(truth = truth, estimate = .pred) ## # A tibble: 2 x 4 ## model .metric .estimator .estimate ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; ## 1 lm rmse standard 0.198 ## 2 rf rmse standard 0.114 Apply model to the test set\nlm_fit1 %\u0026gt;% predict(coff_test) %\u0026gt;% bind_cols(coff_test) %\u0026gt;% metrics(truth = cupper_points, estimate = .pred) %\u0026gt;% bind_cols(model = \u0026quot;lm\u0026quot;) %\u0026gt;% bind_rows( rf_fit1 %\u0026gt;% predict(coff_test) %\u0026gt;% bind_cols(coff_test) %\u0026gt;% metrics(truth = cupper_points, estimate = .pred ) %\u0026gt;% bind_cols(model = \u0026quot;rf\u0026quot;) ) ## # A tibble: 6 x 4 ## .metric .estimator .estimate model ## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 rmse standard 0.244 lm ## 2 rsq standard 0.629 lm ## 3 mae standard 0.144 lm ## 4 rmse standard 0.231 rf ## 5 rsq standard 0.664 rf ## 6 mae standard 0.130 rf We see that the random forest and linear model are both very close together in performance. However, the random forest does have a small RMSE and higher R squared, which means it does a slightly better job explaining the variance and has less overall error in predicting the ratings.\n Next Steps I did all of this analysis without knowing anything about tidymodels. Additionally, I am fairly new to using R for predicting values as well. It would be interesting to see how these models perform with cross-validation, optimized parameters and better feature selection.\nThe concept of a “recipe” which you can modify and reuse is incredibly interesting in this context. I have a lot more to learn here, and would direct readers to the great YouTube videos made by Julia Silge.\n ",
    "ref": "/blog/coffee-ratings/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
